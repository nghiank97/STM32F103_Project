#include "monkey.h"
#include "math.h"

uint8_t serial_rx_buffer[RX_BUFFER_SIZE];
uint16_t serial_rx_buffer_head = 0;
volatile uint16_t serial_rx_buffer_tail = 0;

uint8_t serial_tx_buffer[TX_BUFFER_SIZE];
uint16_t serial_tx_buffer_head = 0;
volatile uint16_t serial_tx_buffer_tail = 0;

// Returns the number of bytes used in the RX serial buffer.
uint8_t serial_get_rx_buffer_count(void)
{
    uint8_t rtail = serial_rx_buffer_tail; // Copy to limit multiple calls to volatile
    if (serial_rx_buffer_head >= rtail)
    {
        return (serial_rx_buffer_head - rtail);
    }
    return (RX_BUFFER_SIZE - (rtail - serial_rx_buffer_head));
}

// Returns the number of bytes used in the TX serial buffer.
// NOTE: Not used except for debugging and ensuring no TX bottlenecks.
uint8_t serial_get_tx_buffer_count(void)
{
    uint8_t ttail = serial_tx_buffer_tail; // Copy to limit multiple calls to volatile
    if (serial_tx_buffer_head >= ttail)
    {
        return (serial_tx_buffer_head - ttail);
    }
    return (TX_BUFFER_SIZE - (ttail - serial_tx_buffer_head));
}

void serial_init(void)
{
    /* enable clock in GPIOA */
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
    GPIOA->CRL |= GPIO_CRL_CNF2_1 | GPIO_CRL_MODE2_1;
    GPIOA->CRL |= GPIO_CRL_CNF3_1 | GPIO_CRL_MODE3_1;

    /* enable clock in UART2 */
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
    /*  Baud rate
			BRR should be 208.333 for 9600 baud rate in 32MHZ
			Thus manista is 208 (0xD0) and fraction is 5 (0x05) (5/16 is .333)
			Making it 0x0D05 */
    USART2->BRR = 0x0D05;
    USART2->CR1 = 0x0000;
    /*  Word length 8 data */
    USART2->CR1 &= ~USART_CR1_M;
    /*  1 stop bits */
    USART2->CR2 &= ~USART_CR2_STOP;
    /* USART enable */
    USART2->CR1 = USART_CR1_RE | USART_CR1_TE | USART_CR1_UE;

    /* Interrupt rx serial */
    USART2->CR1 |= USART_CR1_RXNEIE;
    /* Set priority */
    NVIC->IP[USART2_IRQn] = 0x10;
    ENABLE_INTERRUPT(USART2_IRQn);
}

void USART2_IRQHandler(void)
{
	if((USART2->SR & USART_SR_RXNE) != 0x0000){
    uint8_t data = (uint8_t)(USART2->DR & (uint8_t)0x01FF);
    uint16_t next_head;

    next_head = serial_rx_buffer_head + 1;
    if (next_head == RX_BUFFER_SIZE)
    {
        next_head = 0;
    }
    if (next_head != serial_rx_buffer_tail)
    {
        serial_rx_buffer[serial_rx_buffer_head] = data;
        serial_rx_buffer_head = next_head;
    }
	}
}

void serial_reset_read_buffer(void)
{
    serial_rx_buffer_tail = serial_rx_buffer_head;
}

uint8_t write(char data)
{
    USART2->DR = (data & (uint16_t)0x01FF);
    while ((USART2->SR & USART_SR_TXE) == (uint16_t)0);
		return 1;
}

uint8_t seriale_available(void)
{

    uint16_t head = serial_rx_buffer_head;
    uint16_t tail = serial_rx_buffer_tail;
    if (head >= tail)
    {
        return (head - tail);
    }
    else
    {
        return (RX_BUFFER_SIZE - tail + head);
    }
}

uint8_t serial_read(void)
{
    uint16_t tail = serial_rx_buffer_tail;
    if (serial_rx_buffer_head == tail)
    {
        return SERIAL_NO_DATA;
    }
    else
    {
        uint8_t data = serial_rx_buffer[tail];
        tail++;
        if (tail == RX_BUFFER_SIZE)
        {
            tail = 0;
        }
        serial_rx_buffer_tail = tail;
        return data;
    }
}

uint8_t printNumber(unsigned long n, uint8_t base)
{
  char buf[8 * sizeof(long) + 1];
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
  if (base < 2)
    base = 10;
  do
  {
    char c = n % base;
    n /= base;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while (n);

  return print(str);
}

uint8_t printFloat(double number, uint8_t digits)
{
  uint8_t n = 0;
	uint8_t i = 0;
	unsigned long int_part;
	double rounding;
	double remainder;
	unsigned int toPrint;

  if (isnan(number))
    return print("nan");
  if (isinf(number))
    return print("inf");
  if (number > 4294967040.0)
    return print("ovf");
  if (number < -4294967040.0)
    return print("ovf");
  if (number < 0.0)
  {
    n += write('-');
    number = -number;
  }
  rounding = 0.5;
  for (i = 0; i < digits; ++i)
    rounding /= 10.0;

  number += rounding;
  int_part = (unsigned long)number;
  remainder = number - (double)int_part;
  n += write(int_part);
  if (digits > 0)
  {
    n += write('.');
  }
  while (digits-- > 0)
  {
    remainder *= 10.0;
    toPrint = (unsigned int)(remainder);
    n += write(toPrint);
    remainder -= toPrint;
  }
  return n;
}

uint8_t print(const char *str)
{
	int i;
	uint8_t len = strlen(str);
	for (i = 0; i < len; i++){
		write(str[i]);
	}
	return len;
}

uint8_t println(const char *str)
{
	uint8_t len = print(str);
	len += print("\r\n");
	return len;
}
